import {
    Vector4,
    BufferGeometry,
    Float32BufferAttribute,
    RawShaderMaterial,
    DoubleSide,
    AdditiveBlending,
    Points
} from '../../../node_modules/three/build/three.module.js';

import {
    particles_vertex,
    particles_fragment
} from '../shaders/Shaders.js';

const ParticleSystem = function (numparticles, multiplier, isMobile) {

    var pos = []; // position
    var noises = []; // noise values
    var noise_val = []; // other noise values, this time for 2D noise
    var micronoise_val = []; // Micronoise, another layer of noise
    var angles = [];
    var radiuses = [];

    var nx = 0; // first dimension of noise to pass to particles
    var mnx = 0; // micrnoise, first dimension

    var w = numparticles;
    var h = numparticles;

    for (var x = 0; x < w; x++) {

        var ny = 0;
        var mny = 0;

        var norm_x = x / (w-1);

        var a = norm_x * (Math.PI);

        var r = norm_x * 4000;

        for (var y = 0; y < h; y++) {

            var m = 0.0;

            var b = (y / h) * (Math.PI * 2);

            // Seamless noise
            nx = Math.sin(a);
            ny = Math.sin(b);

            radiuses.push(r);

            angles.push(Math.cos(b));
            angles.push(Math.sin(b));

            // 3 values, x, y, z, for particle position
            // If it is a mobile device, the x position needs to be smaller
            if (isMobile) {
                pos.push(Math.random());
                pos.push(Math.random());
                pos.push(Math.random());
            } else {
                pos.push(Math.random());
                pos.push(Math.random());
                pos.push(Math.random());
            }

            // Noise
            noises.push(Math.random() * 0.000025);

            // 2D noise
            noise_val.push(nx);
            noise_val.push(ny);

            // 2D noises
            micronoise_val.push(mnx);
            micronoise_val.push(mny);

            ny += 0.1;
            mny += 0.1;

        }

        nx += 0.1;
        mnx += 0.1;

    }

    // Create a new Buffer Geometry, better optimized for GPU purpose
    this.geometry = new BufferGeometry();
    this.geometry.setAttribute('position', new Float32BufferAttribute(pos, 3));
    this.geometry.setAttribute('angle', new Float32BufferAttribute(angles, 2));
    this.geometry.setAttribute('radius', new Float32BufferAttribute(radiuses, 1));
    this.geometry.setAttribute('noise_value', new Float32BufferAttribute(noise_val, 2));
    this.geometry.setAttribute('micronoise_value', new Float32BufferAttribute(micronoise_val, 2));

    // Declare the material with the vertex and fragment shader
    this.material = new RawShaderMaterial({
        uniforms: {
            "uTime": {
                value: 0.0
            },
            "geometryDistance": {
                value: 0.0
            },
            "color": {
                value: new Vector4(1.0, 1.0, 1.0, 0.25)
            }
        },
        vertexShader: particles_vertex,
        fragmentShader: particles_fragment,
        side: DoubleSide,
        blending: AdditiveBlending,
        transparent: true,
        depthTest: true,
        depthWrite: true,
        vertexColors: true,
    });

    // The particle system
    this.ParticleSystem = new Points(this.geometry, this.material);
    this.ParticleSystem.position.y = -400;
    this.ParticleSystem.position.z = 10;

    this.update = function (time, geoDist) {

        // Update the uniforms of the particle system
        this.ParticleSystem.material.uniforms.uTime.value = time * 0.0005;
        this.ParticleSystem.material.uniforms.geometryDistance.value = geoDist;
        this.ParticleSystem.material.needsUpdate = true;
        this.ParticleSystem.material.elementsNeedUpdate = true;
    }
}

export {
    ParticleSystem
};